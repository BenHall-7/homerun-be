/* eslint-disable no-unused-vars */
const router = require('express').Router();
const purecrypt = require('purecrypt');
const crypto = require('crypto');
const bcrypt = require('bcryptjs');
const Members = require('../models/members-model.js');
const Households = require('../models/households-model.js');
const Confirmations = require('../models/confirmations-model.js');
const { generateToken } = require('../middleware/token.js');
const sendMail = require('../middleware/sendMail.js');
const templates = require('../middleware/emailTemplates.js');
const uuid = require('uuid').v4;
const axios = require('axios');
const { token } = require('morgan');
const googleAuthMiddleware = require('../middleware/googleAuth');

router.post('/google', googleAuthMiddleware, (req, res) => {
  // console.log(res.googleInfo);

  res.status(200).json({ message: 'Success!', response: res });
});

router.post('/signup', (req, res) => {
  const { email } = req.body;
  if (email) {
    // a user with this email needs to not exist already
    Members.getByEmail(email).then((result) => {
      if (result) {
        res
          .status(400)
          .json({ message: 'A member with that email already exists' });
      } else {
        // if the email doesn't exist
        const hash = uuid();
        // previous confirmations are invalidated
        Confirmations.remove(email)
          .then(() => Confirmations.insert({ hash, email }))
          .then(({ hash, email }) => {
            sendMail(email, templates.confirmation(hash))
              .then(() => {
                res
                  .status(200)
                  .json({
                    message: 'A confirmation email has been sent',
                    email,
                  });
              })
              .catch((e) => {
                res
                  .status(500)
                  .json({ type: 1, message: 'Email service failed to send' });
              });
          })
          .catch((e) => {
            console.log(e);
            res
              .status(500)
              .json({
                type: 0,
                message:
                  'Failed to store confirmation information in the database',
              });
          });
      }
    });
  } else {
    res.status(401).json({ message: 'Request body missing email' });
  }
});

router.post('/login', (req, res) => {
  const credentials = req.body;
  if (credentials.email && credentials.password) {
    Members.getByEmail(credentials.email)
      .then((member) => {
        if (bcrypt.compareSync(credentials.password, member.password)) {
          const token = generateToken(member);
          res.status(200).json({
            message: `Welcome, ${member.email}`,
            token,
            member_id: member.id,
            username: member.username,
          });
        } else {
          res.status(401).json({ message: 'Invalid credentials' });
        }
      })
      .catch(() => {
        res.status(401).json({ message: 'Invalid credentials' });
      });
  } else {
    res.status(400).json({ message: 'Request body missing email or password' });
  }
});

router.post('/confirm', async (req, res) => {
  let { username, password, hash } = req.body;
  const errors = [
    {
      status: 401,
      type: 0,
      message: 'Request body missing username or password',
    },
    { status: 404, type: 1, message: 'Confirmation hash not found' },
    { status: 400, type: 2, message: 'Username is already taken' },
    {
      status: 500,
      type: 3,
      message: 'Unable to insert autogenerated household',
    },
    { status: 500, type: 4, message: 'Unable to insert member' },
  ];
  let cur_err = errors[0];
  if (username && password) {
    try {
      cur_err = errors[1];
      const confirmation = await Confirmations.getByHash(hash);
      if (!confirmation) throw null;

      cur_err = errors[2];
      if (await Members.getByUsername(username)) throw null;

      cur_err = errors[3];
      const householdID = uuid();
      await Households.insert({ id: householdID });

      cur_err = errors[4];
      let member = await Members.insert({
        username,
        email: confirmation.email,
        password: bcrypt.hashSync(password, 14),
        current_household: householdID,
      });

      Confirmations.remove(confirmation.email).then(() => {
        const token = generateToken(member);
        res.status(200).json({
          message: `Welcome, ${member.email}`,
          token,
          member_id: member.id,
          username: member.username,
        });
      });
      // no catch statement necessary
    } catch (e) {
      e && console.log(e);
      res.status(cur_err.status).json({ ...cur_err, status: undefined });
    }
  } else {
    res.status(cur_err.status).json({ ...cur_err, status: undefined });
  }
});

// todo: confirmation requires email but this requires user id instead.
// should have separate db tables for these types of things
router.post('/forgot', (req, res) => {
  const email = req.body.email;
  Members.getByEmail(email)
    .then((member) => {
      const newConfirmation = {
        member_id: member.id,
        hash: uuid(),
      };
      Confirmations.insert(newConfirmation)
        .then(({ hash }) => {
          sendMail(member.email, templates.reset(hash))
            .then(() => {
              res
                .status(200)
                .json({
                  message: 'A password reset link has been sent',
                  email: member.email,
                });
            })
            .catch(() => {
              res
                .status(500)
                .json({ type: 1, message: 'Email service failed to send' });
            });
        })
        .catch(() => {
          res
            .status(500)
            .json({
              type: 0,
              message:
                'Failed to store confirmation information in the database',
            });
        });
    })
    .catch(() => {
      res
        .status(404)
        .json({ message: 'A User with that email address does not exist.' });
    });
});

router.post('/reset', (req, res) => {
  const hash = req.body.hash;
  Confirmations.getByHash(hash)
    .then((confirmation) => {
      const member_id = confirmation.member_id;
      const newPassword = bcrypt.hashSync(req.body.password, 14);
      Members.update(member_id, { password: newPassword })
        .then(() => {
          Confirmations.remove(member_id).then(() => {
            res.status(200).json({ message: 'Your password has been reset.' });
          });
        })
        .catch(() => {
          res.status(500).json({ message: 'Member to update not found' });
        });
    })
    .catch(() => {
      res.status(404).json({ message: 'Invalid confirmation hash' });
    });
});

// TODO: any user is allowed to delete any other user...
router.delete('/:member_id', async (req, res) => {
  try {
    const request = await Members.remove(req.params.member_id);
    res.status(200).json(request);
  } catch (err) {
    res.status(500).json({ Message: 'Unable to delete user' });
  }
});

module.exports = router;
